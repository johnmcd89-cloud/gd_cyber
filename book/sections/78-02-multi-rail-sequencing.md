# 78.2 Multi-rail sequencing

A **power rail** is a named voltage supply inside a device. If a cyberdeck has a 5 volt input and also contains internal supplies such as 3.3 volts for digital input/output and 1.8 volts for memory, each of those supplies is a rail.

A **multi-rail** system is any system that uses more than one rail.

**Sequencing** is the intentional control of how those rails rise at power-up and fall at power-down: their order, their timing, and their ramp rates.

Multi-rail sequencing can sound like a concern reserved for high-end processors. In practice, it shows up in cyberdecks whenever you combine a compute board, storage, a display system, and one or more radios, and you want the overall system to boot reliably from imperfect field power.

This chapter explains why rails exist, what sequencing tries to prevent, and how to implement sequencing conservatively without turning your cyberdeck into an overcomplicated laboratory instrument.

---

## 78.2.1 Why multi-rail systems exist in cyberdecks

A beginner often imagines that “the cyberdeck runs on 5 volts.” That can be true at the connector level, but inside the device, subsystems often require different voltages.

Compute modules, memory, and modern digital interfaces typically require low voltages to reduce power consumption.

Radios may require a mix of analog and digital rails.

Displays and backlights often have their own power requirements.

As a result, many cyberdecks end up with a small “power tree”: an upstream source (often 5 volts), and several downstream rails generated by voltage regulators.

A practical illustration comes from the Raspberry Pi ecosystem. Raspberry Pi documentation describes model-specific current requirements and emphasizes that peripherals and downstream ports have their own limits. [S5] Even if you never design a custom rail, you are already living in a world of multiple power domains and current budgets.

---

## 78.2.2 What sequencing protects you from (failure modes)

Sequencing is not about perfection. It is about preventing predictable categories of failure.

### Inrush and upstream collapse

At power-up, rails must charge capacitance. Some of that capacitance is inside integrated circuits, and some is external capacitance added for transient stability.

If multiple regulators start simultaneously, the combined inrush can exceed what the upstream source can deliver. When that happens, the upstream voltage can droop and regulators can enter unstable behavior, producing non-monotonic rail ramps (a rail that rises, dips, and rises again). That kind of power-up is one of the easiest ways to create “sometimes it boots, sometimes it doesn’t.”

Flex’s overview of processor power sequencing explains this mechanism directly: sequencing spreads inrush energy over time so that the peak demand on the upstream supply is lower. [S2]

### Latch-up and “sneak” current paths (high-level)

Latch-up is a failure mode in which an integrated circuit enters an unintended conductive state, creating high current until power is removed. The detailed semiconductor physics is beyond this book’s scope, but the practical lesson is simple: powering pins in the wrong order can create conditions the device was not designed to tolerate.

A related and more common issue is “sneak” current paths through protection structures. Flex describes how protection diodes can become forward biased if one rail rises before another, causing current to flow into an unpowered rail and potentially causing startup problems. [S2]

For cyberdeck builders, the important takeaway is not to memorize every device’s constraints, but to design so that rails come up in a controlled, monotonic way and that dependent rails are not unintentionally pre-biased.

### Reset timing and undefined digital behavior

Even if rails are “close enough,” a digital system can behave badly when it is released from reset while supplies are still settling.

A common symptom is intermittent boot failure that disappears when you add a longer reset delay.

This is why sequencing is often paired with supervision.

A **supervisor** (also called a reset supervisor or voltage detector) monitors one or more rails and holds the system in reset until the rail(s) are within specification. Microchip’s application note on supervisory circuits frames this family of components and their use in practical systems. [S3]

---

## 78.2.3 Implementation patterns (from simplest to most controlled)

The right sequencing strategy depends on how custom your power system is.

### Pattern A: “One good rail” and let modules handle the rest

Many cyberdecks can avoid custom sequencing by choosing modules that already include their own internal power management.

In this pattern, your responsibility is to provide a stable upstream rail (often 5.1 volts for Raspberry Pi-class systems), sufficient current, and reasonable transient behavior. [S5]

You still validate boot reliability under load, but you avoid designing multiple regulators yourself.

### Pattern B: Daisy-chained enables and power-good signals

If you do generate your own rails, many regulators provide:

- an **enable** pin (the regulator only turns on when enabled)
- a **power-good** output (a signal that asserts when the rail is within regulation)

A common sequencing approach is to enable the first rail, then use its power-good to enable the next rail, and so on.

This is conceptually simple and can be robust, but it requires careful thought about fault conditions: if a later rail fails, should earlier rails shut off, or should the system remain partially powered?

### Pattern C: Reset supervision as the “glue”

Even a well-sequenced system can fail if the processor leaves reset too early.

A reset supervisor is a small component that observes one or more rails and produces a clean reset pulse with a specified delay.

Texas Instruments’ application brief on creating a sequencing voltage supervisor using the TPS386000 family illustrates how reset behavior can be combined with sequencing logic. [S4]

In cyberdecks, supervisors are especially useful because they create deterministic behavior from messy real-world power. If you are debugging “random” boot problems, adding supervision is often a more productive step than redesigning the entire power tree.

### Pattern D: Dedicated sequencers (multi-rail controllers)

When the number of rails grows, it can be easier to use a dedicated sequencer.

Silicon Labs’ three-channel power sequencer application note is an example of the class of documents that describe sequencing controllers and typical timing schemes. [S6]

A dedicated sequencer is not mandatory for most cyberdecks, but the concept is worth knowing because it explains how professional multi-rail systems avoid ad-hoc timing chains.

---

## 78.2.4 Cyberdeck-specific guidance: when to care, and when not to

Multi-rail sequencing is essential when:

- you design a custom carrier or backplane that generates several rails
- you integrate high-current radios, displays, and storage from a single upstream supply
- you observe brownouts, reboot loops, or intermittent boots that correlate with load steps

Multi-rail sequencing is usually not the first priority when:

- your deck uses a well-supported single-board computer with an official power supply
- you have only one externally generated rail and everything else is internal to modules

This is an important discipline: do not invent a complicated sequencing circuit to compensate for an under-sized power supply or bad cabling. Fix the fundamentals first.

---

## 78.2.5 Validation checklist

A minimal checklist for sequencing and supervision is:

- Rails rise monotonically, meaning they do not dip during power-up.
- The system remains in reset until the relevant rail(s) are in regulation, and reset release is repeatable.
- A “worst-case boot” test is performed with the maximum expected load attached (display at full brightness, radios active, storage attached).
- Fault behavior is intentional: if one rail fails, the system either shuts down cleanly or remains in a safe, predictable state.

---

## Suggested figures

1) **Power tree diagram**: upstream input → regulators → rails → loads (compute, radios, display, storage).
2) **Timing diagram**: rail voltages vs time with enable, power-good, and reset signals.
3) **Inrush illustration**: simultaneous startup vs sequenced startup and the effect on upstream droop.
4) **Protection diode “sneak path” sketch**: why pre-bias can occur if rails rise in the wrong order (conceptual). [S2]

---

## Sources

Community and culture sources:

- [S1] Hackaday: *cyberdeck* tag index (secondary overview of real builds and integration constraints) — https://hackaday.com/tag/cyberdeck/

Technical and vendor references:

- [S2] Flex Power Modules: *Processor power sequencing* (sequencing rationale; inrush; protection-diode sneak paths; ramp requirements) — https://flexpowermodules.com/processor-power-sequencing
- [S3] Microchip: *Understanding and Using Supervisory Circuits* (application note PDF) — https://ww1.microchip.com/downloads/en/AppNotes/00686a.pdf
- [S4] Texas Instruments: *Creating a Sequencing Voltage Supervisor (Reset IC) Using TPS386000 and …* (application brief PDF) — https://www.ti.com/lit/pdf/snva844
- [S5] Raspberry Pi Documentation (GitHub): *Power supply* (model-dependent power constraints and downstream current limits) — https://raw.githubusercontent.com/raspberrypi/documentation/master/documentation/asciidoc/computers/raspberry-pi/power-supplies.adoc
- [S6] Silicon Labs: *AN145: Three-Channel Power Sequencer* (application note PDF) — https://www.silabs.com/documents/public/application-notes/an145.pdf

Additional textbook references (background):

- Erickson and Maksimović, *Fundamentals of Power Electronics* (transient behavior and control concepts relevant to rail stability).
